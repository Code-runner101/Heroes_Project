# Heroes Project

Проект реализует симуляцию пошагового боя между двумя армиями юнитов. В рамках проекта разработаны алгоритмы генерации армии, симуляции боя, выбора целей для атаки и поиска пути на игровом поле.

---

## Реализованные алгоритмы

### 1. Генерация армии (`GeneratePresetImpl`)

Алгоритм формирует армию на основе списка доступных типов юнитов с учётом ограничений игрового поля, максимального бюджета и лимита на количество юнитов одного типа.

#### Описание алгоритма
- Определяется минимальная стоимость юнита для контроля возможности дальнейшей генерации.
- Пока доступный бюджет позволяет добавить хотя бы одного юнита:
    - Отбираются юниты, удовлетворяющие ограничениям по стоимости и количеству экземпляров одного типа.
    - Для каждого кандидата вычисляется эффективность по формуле:

      ```
      (BaseAttack + Health) / Cost
      ```

    - Из юнитов с максимальной эффективностью выбирается один случайным образом.
    - Выбирается свободная клетка на игровом поле.
    - Создаётся новый экземпляр юнита с уникальным именем и заданными координатами.
    - Обновляются счётчики бюджета и количества юнитов данного типа.

#### Алгоритмическая сложность
- Пусть `n` — количество типов юнитов,  
  `m` — максимальное количество юнитов в армии.
- Отбор кандидатов и вычисление эффективности: `O(n)`
- Выбор свободной клетки: `O(W * H)`, где `W` и `H` — размеры игрового поля.
- Алгоритм выполняется не более `m` раз.

**Итоговая сложность:**  
`O(n * m)`

---

### 2. Симуляция боя (`SimulateBattleImpl`)

Алгоритм моделирует пошаговое сражение двух армий до полного уничтожения одной из сторон.

#### Описание алгоритма
- В каждом раунде формируется список всех живых юнитов обеих армий.
- Юниты сортируются по убыванию базовой атаки.
- Каждый юнит по очереди выполняет атаку, используя собственную стратегию выбора цели.
- Все действия логируются.
- Раунды повторяются до завершения боя.

#### Алгоритмическая сложность
Обозначим:
- `n` — общее количество юнитов в обеих армиях;
- `r` — количество раундов боя.

Сложность операций в одном раунде:
- Формирование списка живых юнитов: **O(n)**.
- Сортировка списка `allUnits`: **O(n log n)**.
- Последовательный обход юнитов и выполнение атак: **O(n)**.
- Проверка наличия живых юнитов: **O(n)**.

Таким образом, сложность одного раунда:
`O(n log n)`

Так как количество раундов в худшем случае пропорционально количеству юнитов (каждый раунд как минимум один юнит погибает), общая сложность симуляции:
`O(r × n log n) ≈ O(n² log n)`

---

### 3. Определение подходящих целей для атаки (`SuitableForAttackUnitsFinderImpl`)

Алгоритм определяет список юнитов, доступных для атаки, с учётом их положения в ряду и наличия блокирующих юнитов.

#### Описание алгоритма
- Армия представляется в виде списка рядов.
- Для каждого юнита проверяется:
    - жив ли он;
    - не заблокирован ли другим юнитом со стороны противника.
- Юниты, не имеющие блокировки, добавляются в список доступных целей.

#### Алгоритмическая сложность
Обозначим:
- `n` — общее количество юнитов во всех рядах.

Каждый юнит:
- посещается ровно один раз;
- для него выполняется константное число операций (проверка соседней ячейки).

Общая сложность алгоритма:
`O(n)`

Дополнительная память:
- список результатов — **O(n)** в худшем случае.

---

### 4. Поиск пути к цели (`UnitTargetPathFinderImpl`)

Для нахождения кратчайшего пути между атакующим юнитом и целью используется алгоритм Дейкстры с возможностью диагонального перемещения.

#### Описание алгоритма
- Игровое поле представляется в виде двумерной сетки.
- Формируется множество занятых клеток.
- Для каждой клетки вычисляется минимальная стоимость достижения.
- Используется приоритетная очередь для выбора клетки с минимальной дистанцией.
- После достижения цели путь восстанавливается по массиву предшественников.

#### Алгоритмическая сложность
- Пусть `V = WIDTH * HEIGHT` — количество клеток поля.
- Каждая клетка имеет до 8 соседей.
- Алгоритм Дейкстры с приоритетной очередью выполняется за `O(E log V)`,
  где `E ≈ 8V`.

**Итоговая сложность:**  
`O(V log V)`

---

## Развёртывание и запуск проекта

Для запуска симулятора необходимо собрать jar-файл с реализацией и поместить его в каталог с основной игрой.

### Шаги развёртывания

1. Перейдите в корневую папку проекта.  
   **Важно:** путь к проекту не должен содержать латиницы.
2. Выполните сборку проекта с помощью Gradle:  
```
./gradlew :heroes_student_task:clean :heroes_student_task:buildJar
```  
> При отсутствии Gradle и Java 20 версии и более, необходимо их предварительно установить.  
3. Скопируйте собранный jar-файл в каталог с игрой:
- **Для MacOS / Linux:**
  ```
  cp heroes_student_task/build/libs/heroes_task_impl-1.0-SNAPSHOT.jar heroes/jars/obf.jar
  ```
- **Для Windows (CMD):**
  ```
  copy heroes_student_task\build\libs\heroes_task_impl-1.0-SNAPSHOT.jar heroes\jars\obf.jar
  ```
- **Для Windows (PowerShell):**
  ```
  Copy-Item heroes_student_task\build\libs\heroes_task_impl-1.0-SNAPSHOT.jar heroes\jars\obf.jar
  ```  
> Если путь или имя файла содержит пробелы, берите их в кавычки.  
4. Перейдите в папку с игрой:  
```
cd heroes
```
5. Запустите симулятор:  
```
java -jar “Heroes Battle-1.0.0.jar”
```